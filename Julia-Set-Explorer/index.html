<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Julia Set Explorer</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            background: #0a0a0f;
            color: #e0e0e0;
            font-family: 'Segoe UI', system-ui, sans-serif;
            min-height: 100vh;
            overflow-x: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        h1 {
            font-size: 2.2rem;
            margin-top: 16px;
            background: linear-gradient(135deg, #ff6b6b, #c084fc, #38bdf8);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            color: #888;
            font-size: 0.82rem;
            margin: 4px 0 12px;
            text-align: center;
            padding: 0 16px;
        }

        .main-area {
            display: flex;
            gap: 14px;
            flex-wrap: wrap;
            justify-content: center;
            padding: 0 12px 20px;
        }

        /* ---------- Canvas panels ---------- */
        .panel {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .panel-label {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 6px;
            padding: 3px 14px;
            border-radius: 12px;
            font-weight: 600;
        }

        .panel-label.mandel {
            color: #38bdf8;
            background: rgba(56, 189, 248, 0.1);
            border: 1px solid rgba(56, 189, 248, 0.25);
        }

        .panel-label.julia {
            color: #c084fc;
            background: rgba(192, 132, 252, 0.1);
            border: 1px solid rgba(192, 132, 252, 0.25);
        }

        .canvas-wrap {
            position: relative;
        }

        .canvas-wrap canvas {
            border: 2px solid #333;
            border-radius: 8px;
            cursor: crosshair;
            display: block;
        }

        .canvas-wrap.mandel-wrap canvas {
            box-shadow: 0 0 24px rgba(56, 189, 248, 0.15);
        }

        .canvas-wrap.julia-wrap canvas {
            box-shadow: 0 0 24px rgba(192, 132, 252, 0.15);
        }

        .overlay-info {
            position: absolute;
            top: 8px;
            left: 8px;
            background: rgba(0,0,0,0.65);
            color: #ccc;
            font-size: 0.68rem;
            padding: 4px 8px;
            border-radius: 4px;
            pointer-events: none;
            white-space: nowrap;
        }

        /* Crosshair overlay on Mandelbrot — receives pointer events for click-to-pick-c */
        .crosshair-overlay {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: auto;
            cursor: crosshair;
        }

        /* ---------- Controls ---------- */
        .controls {
            background: #13131a;
            border: 1px solid #2a2a3a;
            border-radius: 10px;
            padding: 14px;
            width: 220px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            max-height: 580px;
            overflow-y: auto;
        }

        .controls h3 {
            font-size: 0.78rem;
            color: #c084fc;
            text-transform: uppercase;
            letter-spacing: 1px;
            border-bottom: 1px solid #2a2a3a;
            padding-bottom: 5px;
        }

        .ctrl-row {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .ctrl-row label {
            font-size: 0.7rem;
            color: #999;
        }

        .ctrl-row input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 5px;
            border-radius: 3px;
            background: #222;
            outline: none;
        }

        .ctrl-row input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 13px;
            height: 13px;
            border-radius: 50%;
            background: #c084fc;
            cursor: pointer;
        }

        .ctrl-row .val {
            font-size: 0.65rem;
            color: #666;
            text-align: right;
        }

        .presets {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 5px;
        }

        .presets button, .btn {
            background: #1e1e2e;
            border: 1px solid #333;
            color: #ddd;
            padding: 5px 6px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.68rem;
            transition: all 0.15s;
        }

        .presets button:hover, .btn:hover {
            background: #2a2a40;
            border-color: #c084fc;
            color: #fff;
        }

        .btn-wide { grid-column: 1 / -1; }

        .color-row {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
        }

        .color-swatch {
            width: 26px;
            height: 26px;
            border-radius: 5px;
            border: 2px solid transparent;
            cursor: pointer;
            transition: border-color 0.15s, transform 0.15s;
        }

        .color-swatch:hover, .color-swatch.active {
            border-color: #fff;
            transform: scale(1.15);
        }

        .keys-help {
            font-size: 0.6rem;
            color: #555;
            line-height: 1.6;
        }

        .keys-help kbd {
            background: #222;
            padding: 1px 4px;
            border-radius: 3px;
            border: 1px solid #444;
            font-family: inherit;
        }

        .link-line {
            position: absolute;
            pointer-events: none;
            z-index: 10;
        }

        /* Responsive: stack vertically on narrow screens */
        @media (max-width: 1100px) {
            .main-area { flex-direction: column; align-items: center; }
            .controls { width: 90vw; max-width: 500px; max-height: none; flex-direction: row; flex-wrap: wrap; gap: 14px; }
            .controls h3 { width: 100%; }
        }
    </style>
</head>
<body>
    <h1>Julia Set Explorer</h1>
    <p class="subtitle">Click anywhere on the Mandelbrot to pick <strong>c</strong> &mdash; scroll to zoom, drag to pan on either view</p>

    <div class="main-area">
        <!-- Mandelbrot panel -->
        <div class="panel">
            <div class="panel-label mandel">Mandelbrot Set</div>
            <div class="canvas-wrap mandel-wrap">
                <canvas id="mandelbrot" width="560" height="560"></canvas>
                <canvas id="crosshairCanvas" class="crosshair-overlay" width="560" height="560"></canvas>
                <div class="overlay-info" id="mandelInfo">Zoom: 1.00x</div>
            </div>
        </div>

        <!-- Controls panel -->
        <div class="controls">
            <h3>Constant c</h3>
            <div class="ctrl-row">
                <label>Real (c<sub>r</sub>)</label>
                <input type="range" id="cReal" min="-2" max="2" step="0.001" value="-0.7">
                <span class="val" id="cRealVal">-0.700</span>
            </div>
            <div class="ctrl-row">
                <label>Imaginary (c<sub>i</sub>)</label>
                <input type="range" id="cImag" min="-2" max="2" step="0.001" value="0.27015">
                <span class="val" id="cImagVal">0.270</span>
            </div>

            <h3>Rendering</h3>
            <div class="ctrl-row">
                <label>Max Iterations</label>
                <input type="range" id="maxIter" min="50" max="1000" step="10" value="300">
                <span class="val" id="maxIterVal">300</span>
            </div>
            <div class="ctrl-row">
                <label>Escape Radius</label>
                <input type="range" id="escapeR" min="2" max="20" step="0.5" value="4">
                <span class="val" id="escapeRVal">4.0</span>
            </div>

            <h3>Palette</h3>
            <div class="color-row" id="palettes"></div>

            <h3>Presets</h3>
            <div class="presets" id="presetBtns"></div>

            <button class="btn btn-wide" id="resetJulia">Reset Julia View</button>
            <button class="btn btn-wide" id="resetMandel">Reset Mandelbrot View</button>
            <button class="btn btn-wide" id="saveJulia">Save Julia PNG</button>
            <button class="btn btn-wide" id="saveMandel">Save Mandelbrot PNG</button>
            <button class="btn btn-wide" id="toggleAnimate">Animate c</button>

            <h3>Keys</h3>
            <div class="keys-help">
                <kbd>Scroll</kbd> Zoom &nbsp; <kbd>Drag</kbd> Pan<br>
                <kbd>R</kbd> Reset both &nbsp; <kbd>A</kbd> Animate<br>
                <kbd>S</kbd> Save Julia &nbsp; <kbd>1-6</kbd> Palette
            </div>
        </div>

        <!-- Julia panel -->
        <div class="panel">
            <div class="panel-label julia">Julia Set</div>
            <div class="canvas-wrap julia-wrap">
                <canvas id="julia" width="560" height="560"></canvas>
                <div class="overlay-info" id="juliaInfo">Zoom: 1.00x</div>
            </div>
        </div>
    </div>

<script>
/* ============================================================
   Julia Set Explorer — Dual View
   ============================================================ */

// --- Canvas refs ---
const juliaCanvas   = document.getElementById('julia');
const juliaCtx      = juliaCanvas.getContext('2d');
const mandelCanvas  = document.getElementById('mandelbrot');
const mandelCtx     = mandelCanvas.getContext('2d');
const crossCanvas   = document.getElementById('crosshairCanvas');
const crossCtx      = crossCanvas.getContext('2d');

const JW = juliaCanvas.width,  JH = juliaCanvas.height;
const MW = mandelCanvas.width, MH = mandelCanvas.height;

const juliaImg  = juliaCtx.createImageData(JW, JH);
const jBuf      = juliaImg.data;
const mandelImg = mandelCtx.createImageData(MW, MH);
const mBuf      = mandelImg.data;

// --- State ---
let cr = -0.7, ci = 0.27015;

// Julia view
let jCenterX = 0, jCenterY = 0, jZoom = 1;

// Mandelbrot view
let mCenterX = -0.5, mCenterY = 0, mZoom = 1;

let maxIter = 300, escapeR = 4;
let paletteIdx = 0;
let animating = false, animAngle = 0;

// --- Palettes ---
const palettes = [
    { name: 'Ultraviolet',  colors: ['#0a0020','#3a0ca3','#7209b7','#f72585','#ffba08'] },
    { name: 'Ocean',        colors: ['#03071e','#023e8a','#0077b6','#00b4d8','#90e0ef'] },
    { name: 'Inferno',      colors: ['#000004','#420a68','#932567','#dd513a','#fca50a'] },
    { name: 'Emerald',      colors: ['#001219','#005f73','#0a9396','#94d2bd','#e9d8a6'] },
    { name: 'Grayscale',    colors: ['#000000','#444444','#888888','#bbbbbb','#ffffff'] },
    { name: 'Neon',         colors: ['#0d0221','#0d6986','#48e5c2','#f3ff33','#ff3366'] },
];

function hexToRgb(hex) {
    const v = parseInt(hex.slice(1), 16);
    return [(v >> 16) & 255, (v >> 8) & 255, v & 255];
}

const palLUTs = palettes.map(p => {
    const cols = p.colors.map(hexToRgb);
    const lut = new Uint8Array(256 * 3);
    for (let i = 0; i < 256; i++) {
        const t = i / 255 * (cols.length - 1);
        const idx = Math.floor(t);
        const f = t - idx;
        const a = cols[Math.min(idx, cols.length - 1)];
        const b = cols[Math.min(idx + 1, cols.length - 1)];
        lut[i * 3]     = a[0] + (b[0] - a[0]) * f;
        lut[i * 3 + 1] = a[1] + (b[1] - a[1]) * f;
        lut[i * 3 + 2] = a[2] + (b[2] - a[2]) * f;
    }
    return lut;
});

// --- Presets ---
const presets = [
    { name: 'Dendrite',     cr: -0.7,    ci:  0.27015 },
    { name: 'Lightning',    cr: -0.8,    ci:  0.156   },
    { name: 'Spiral',       cr:  0.285,  ci:  0.01    },
    { name: 'Starfish',     cr: -0.4,    ci:  0.6     },
    { name: 'Snowflake',    cr:  0.36,   ci:  0.1     },
    { name: 'Galaxy',       cr: -0.7269, ci:  0.1889  },
    { name: 'Dragon',       cr: -0.835,  ci: -0.2321  },
    { name: 'Douady Rabbit',cr: -0.123,  ci:  0.745   },
    { name: 'San Marco',    cr: -0.75,   ci:  0.0     },
    { name: 'Siegel Disk',  cr: -0.391,  ci: -0.587   },
];

// --- Smooth iteration coloring helper ---
function smoothColor(i, zr, zi, maxIt, lut, buf, off) {
    if (i === maxIt) {
        buf[off] = buf[off + 1] = buf[off + 2] = 0;
    } else {
        const log2 = Math.log(2);
        const nu = Math.log(Math.log(zr * zr + zi * zi) / log2) / log2;
        const smooth = (i + 1 - nu) / maxIt * 255;
        const ci2 = Math.max(0, Math.min(255, smooth * 4)) | 0;
        buf[off]     = lut[ci2 * 3];
        buf[off + 1] = lut[ci2 * 3 + 1];
        buf[off + 2] = lut[ci2 * 3 + 2];
    }
    buf[off + 3] = 255;
}

// ======================== JULIA RENDER ========================
function renderJulia() {
    const lut = palLUTs[paletteIdx];
    const er2 = escapeR * escapeR;
    const scale = 3 / (jZoom * JW);
    const ox = jCenterX - (JW / 2) * scale;
    const oy = jCenterY - (JH / 2) * scale;

    for (let py = 0; py < JH; py++) {
        const y0 = oy + py * scale;
        for (let px = 0; px < JW; px++) {
            let zr = ox + px * scale;
            let zi = y0;
            let i = 0;
            while (i < maxIter && zr * zr + zi * zi < er2) {
                const tmp = zr * zr - zi * zi + cr;
                zi = 2 * zr * zi + ci;
                zr = tmp;
                i++;
            }
            smoothColor(i, zr, zi, maxIter, lut, jBuf, (py * JW + px) * 4);
        }
    }
    juliaCtx.putImageData(juliaImg, 0, 0);
    document.getElementById('juliaInfo').textContent =
        `Zoom: ${jZoom.toFixed(2)}x  |  c = ${cr.toFixed(4)} + ${ci.toFixed(4)}i`;
}

// ======================== MANDELBROT RENDER ========================
function renderMandelbrot() {
    const lut = palLUTs[paletteIdx];
    const er2 = escapeR * escapeR;
    const scale = 3.5 / (mZoom * MW);
    const ox = mCenterX - (MW / 2) * scale;
    const oy = mCenterY - (MH / 2) * scale;

    for (let py = 0; py < MH; py++) {
        const y0 = oy + py * scale;
        for (let px = 0; px < MW; px++) {
            const x0 = ox + px * scale;
            let zr = 0, zi = 0;
            let i = 0;
            while (i < maxIter && zr * zr + zi * zi < er2) {
                const tmp = zr * zr - zi * zi + x0;
                zi = 2 * zr * zi + y0;
                zr = tmp;
                i++;
            }
            smoothColor(i, zr, zi, maxIter, lut, mBuf, (py * MW + px) * 4);
        }
    }
    mandelCtx.putImageData(mandelImg, 0, 0);
    document.getElementById('mandelInfo').textContent =
        `Zoom: ${mZoom.toFixed(2)}x  |  Click to pick c`;
}

// ======================== CROSSHAIR ON MANDELBROT ========================
function drawCrosshair() {
    crossCtx.clearRect(0, 0, MW, MH);
    const scale = 3.5 / (mZoom * MW);
    const ox = mCenterX - (MW / 2) * scale;
    const oy = mCenterY - (MH / 2) * scale;
    const px = (cr - ox) / scale;
    const py = (ci - oy) / scale;

    // Only draw if visible
    if (px < -20 || px > MW + 20 || py < -20 || py > MH + 20) return;

    crossCtx.save();
    crossCtx.strokeStyle = 'rgba(255,255,255,0.7)';
    crossCtx.lineWidth = 1;
    crossCtx.setLineDash([6, 4]);

    // Horizontal line
    crossCtx.beginPath();
    crossCtx.moveTo(0, py);
    crossCtx.lineTo(MW, py);
    crossCtx.stroke();

    // Vertical line
    crossCtx.beginPath();
    crossCtx.moveTo(px, 0);
    crossCtx.lineTo(px, MH);
    crossCtx.stroke();

    crossCtx.setLineDash([]);

    // Center dot
    crossCtx.fillStyle = '#fff';
    crossCtx.shadowColor = '#c084fc';
    crossCtx.shadowBlur = 10;
    crossCtx.beginPath();
    crossCtx.arc(px, py, 5, 0, Math.PI * 2);
    crossCtx.fill();

    // Ring
    crossCtx.shadowBlur = 0;
    crossCtx.strokeStyle = '#c084fc';
    crossCtx.lineWidth = 2;
    crossCtx.beginPath();
    crossCtx.arc(px, py, 8, 0, Math.PI * 2);
    crossCtx.stroke();

    // Label
    crossCtx.fillStyle = 'rgba(0,0,0,0.7)';
    const label = `c = ${cr.toFixed(3)} + ${ci.toFixed(3)}i`;
    const lx = Math.min(px + 14, MW - 140);
    const ly = Math.max(py - 12, 16);
    const tw = crossCtx.measureText(label).width + 10;
    crossCtx.fillRect(lx - 4, ly - 11, tw, 16);
    crossCtx.fillStyle = '#e0e0e0';
    crossCtx.font = '11px system-ui, sans-serif';
    crossCtx.fillText(label, lx, ly);

    crossCtx.restore();
}

// --- Throttled renders ---
let jPending = false, mPending = false;
function requestJuliaRender() {
    if (!jPending) {
        jPending = true;
        requestAnimationFrame(() => { renderJulia(); drawCrosshair(); jPending = false; });
    }
}
function requestMandelRender() {
    if (!mPending) {
        mPending = true;
        requestAnimationFrame(() => { renderMandelbrot(); drawCrosshair(); mPending = false; });
    }
}
function requestBothRender() {
    requestJuliaRender();
    requestMandelRender();
}

// --- Controls ---
const sliderCr   = document.getElementById('cReal');
const sliderCi   = document.getElementById('cImag');
const sliderIter = document.getElementById('maxIter');
const sliderEsc  = document.getElementById('escapeR');

function syncSlidersFromState() {
    sliderCr.value = cr;   document.getElementById('cRealVal').textContent = cr.toFixed(3);
    sliderCi.value = ci;   document.getElementById('cImagVal').textContent = ci.toFixed(3);
    sliderIter.value = maxIter; document.getElementById('maxIterVal').textContent = maxIter;
    sliderEsc.value = escapeR;  document.getElementById('escapeRVal').textContent = escapeR.toFixed(1);
}

sliderCr.addEventListener('input', () => { cr = +sliderCr.value; syncSlidersFromState(); requestJuliaRender(); drawCrosshair(); });
sliderCi.addEventListener('input', () => { ci = +sliderCi.value; syncSlidersFromState(); requestJuliaRender(); drawCrosshair(); });
sliderIter.addEventListener('input', () => { maxIter = +sliderIter.value; syncSlidersFromState(); requestBothRender(); });
sliderEsc.addEventListener('input', () => { escapeR = +sliderEsc.value; syncSlidersFromState(); requestBothRender(); });

// --- Palette swatches ---
const palContainer = document.getElementById('palettes');
palettes.forEach((p, i) => {
    const sw = document.createElement('div');
    sw.className = 'color-swatch' + (i === 0 ? ' active' : '');
    sw.title = p.name;
    sw.style.background = `linear-gradient(135deg, ${p.colors.join(',')})`;
    sw.addEventListener('click', () => {
        palContainer.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('active'));
        sw.classList.add('active');
        paletteIdx = i;
        requestBothRender();
    });
    palContainer.appendChild(sw);
});

// --- Preset buttons ---
const presetContainer = document.getElementById('presetBtns');
presets.forEach(p => {
    const btn = document.createElement('button');
    btn.textContent = p.name;
    btn.addEventListener('click', () => {
        cr = p.cr; ci = p.ci;
        syncSlidersFromState();
        requestJuliaRender();
        drawCrosshair();
    });
    presetContainer.appendChild(btn);
});

// ======================== PAN & ZOOM (shared logic) ========================
function setupPanZoom(cvs, getState, setState, onRender, baseSpan, cvsW, cvsH) {
    let dragging = false, dragX, dragY, dragMoved = false;

    cvs.addEventListener('mousedown', e => {
        dragging = true;
        dragMoved = false;
        dragX = e.clientX;
        dragY = e.clientY;
        cvs.style.cursor = 'grabbing';
    });

    window.addEventListener('mousemove', e => {
        if (!dragging) return;
        const st = getState();
        const scale = baseSpan / (st.zoom * cvsW);
        setState({
            cx: st.cx - (e.clientX - dragX) * scale,
            cy: st.cy - (e.clientY - dragY) * scale,
            zoom: st.zoom
        });
        dragX = e.clientX;
        dragY = e.clientY;
        dragMoved = true;
        onRender();
    });

    window.addEventListener('mouseup', () => {
        if (dragging) {
            dragging = false;
            cvs.style.cursor = 'crosshair';
        }
    });

    cvs.addEventListener('wheel', e => {
        e.preventDefault();
        const rect = cvs.getBoundingClientRect();
        const mx = e.clientX - rect.left;
        const my = e.clientY - rect.top;
        const st = getState();
        const scale = baseSpan / (st.zoom * cvsW);
        const wx = st.cx + (mx - cvsW / 2) * scale;
        const wy = st.cy + (my - cvsH / 2) * scale;
        const factor = e.deltaY < 0 ? 1.15 : 1 / 1.15;
        const newZoom = st.zoom * factor;
        const newScale = baseSpan / (newZoom * cvsW);
        setState({
            cx: wx - (mx - cvsW / 2) * newScale,
            cy: wy - (my - cvsH / 2) * newScale,
            zoom: newZoom
        });
        onRender();
    }, { passive: false });

    // Touch support
    let lastTouchDist = 0;
    cvs.addEventListener('touchstart', e => {
        e.preventDefault();
        if (e.touches.length === 1) {
            dragging = true; dragMoved = false;
            dragX = e.touches[0].clientX;
            dragY = e.touches[0].clientY;
        } else if (e.touches.length === 2) {
            const dx = e.touches[0].clientX - e.touches[1].clientX;
            const dy = e.touches[0].clientY - e.touches[1].clientY;
            lastTouchDist = Math.sqrt(dx * dx + dy * dy);
        }
    }, { passive: false });

    cvs.addEventListener('touchmove', e => {
        e.preventDefault();
        if (e.touches.length === 1 && dragging) {
            const st = getState();
            const scale = baseSpan / (st.zoom * cvsW);
            setState({
                cx: st.cx - (e.touches[0].clientX - dragX) * scale,
                cy: st.cy - (e.touches[0].clientY - dragY) * scale,
                zoom: st.zoom
            });
            dragX = e.touches[0].clientX;
            dragY = e.touches[0].clientY;
            dragMoved = true;
            onRender();
        } else if (e.touches.length === 2) {
            const dx = e.touches[0].clientX - e.touches[1].clientX;
            const dy = e.touches[0].clientY - e.touches[1].clientY;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (lastTouchDist > 0) {
                const st = getState();
                setState({ cx: st.cx, cy: st.cy, zoom: st.zoom * (dist / lastTouchDist) });
                onRender();
            }
            lastTouchDist = dist;
        }
    }, { passive: false });

    cvs.addEventListener('touchend', () => { dragging = false; lastTouchDist = 0; });

    return { wasDrag: () => dragMoved };
}

// Julia pan/zoom
const juliaPZ = setupPanZoom(
    juliaCanvas,
    () => ({ cx: jCenterX, cy: jCenterY, zoom: jZoom }),
    s  => { jCenterX = s.cx; jCenterY = s.cy; jZoom = s.zoom; },
    requestJuliaRender, 3, JW, JH
);

// Mandelbrot pan/zoom (use crosshair canvas for events so clicks register on top layer)
const mandelPZ = setupPanZoom(
    crossCanvas,
    () => ({ cx: mCenterX, cy: mCenterY, zoom: mZoom }),
    s  => { mCenterX = s.cx; mCenterY = s.cy; mZoom = s.zoom; },
    requestMandelRender, 3.5, MW, MH
);

// Click on Mandelbrot → pick c
crossCanvas.addEventListener('click', e => {
    if (mandelPZ.wasDrag()) return;
    const rect = crossCanvas.getBoundingClientRect();
    const mx = (e.clientX - rect.left) / rect.width * MW;
    const my = (e.clientY - rect.top)  / rect.height * MH;
    const scale = 3.5 / (mZoom * MW);
    const ox = mCenterX - (MW / 2) * scale;
    const oy = mCenterY - (MH / 2) * scale;
    cr = ox + mx * scale;
    ci = oy + my * scale;
    syncSlidersFromState();
    requestJuliaRender();
    drawCrosshair();
});

// --- Buttons ---
document.getElementById('resetJulia').addEventListener('click', () => {
    jCenterX = 0; jCenterY = 0; jZoom = 1;
    requestJuliaRender();
});

document.getElementById('resetMandel').addEventListener('click', () => {
    mCenterX = -0.5; mCenterY = 0; mZoom = 1;
    requestMandelRender();
});

document.getElementById('saveJulia').addEventListener('click', () => {
    const link = document.createElement('a');
    link.download = `julia_${cr.toFixed(4)}_${ci.toFixed(4)}.png`;
    link.href = juliaCanvas.toDataURL('image/png');
    link.click();
});

document.getElementById('saveMandel').addEventListener('click', () => {
    const link = document.createElement('a');
    link.download = `mandelbrot_zoom${mZoom.toFixed(1)}.png`;
    link.href = mandelCanvas.toDataURL('image/png');
    link.click();
});

document.getElementById('toggleAnimate').addEventListener('click', () => {
    animating = !animating;
    document.getElementById('toggleAnimate').textContent = animating ? 'Stop Animation' : 'Animate c';
    if (animating) animateLoop();
});

function animateLoop() {
    if (!animating) return;
    animAngle += 0.008;
    cr = 0.7885 * Math.cos(animAngle);
    ci = 0.7885 * Math.sin(animAngle);
    syncSlidersFromState();
    renderJulia();
    drawCrosshair();
    requestAnimationFrame(animateLoop);
}

// --- Keyboard shortcuts ---
window.addEventListener('keydown', e => {
    const tag = e.target.tagName;
    if (tag === 'INPUT' || tag === 'TEXTAREA') return;
    if (e.key === 'r' || e.key === 'R') {
        jCenterX = 0; jCenterY = 0; jZoom = 1;
        mCenterX = -0.5; mCenterY = 0; mZoom = 1;
        requestBothRender();
    }
    if (e.key === 'a' || e.key === 'A') document.getElementById('toggleAnimate').click();
    if (e.key === 's' || e.key === 'S') document.getElementById('saveJulia').click();
    if (e.key >= '1' && e.key <= '6') {
        const idx = +e.key - 1;
        if (idx < palettes.length) {
            palContainer.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('active'));
            palContainer.children[idx].classList.add('active');
            paletteIdx = idx;
            requestBothRender();
        }
    }
});

// --- Init ---
syncSlidersFromState();
renderMandelbrot();
renderJulia();
drawCrosshair();
</script>
</body>
</html>
