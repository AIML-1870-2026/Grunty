<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Snake Game</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                    colors: {
                        snake: {
                            green: '#22c55e',
                            dark: '#15803d',
                            bg: '#0f172a',
                            card: '#1e293b',
                            grid: '#334155',
                        }
                    }
                }
            }
        }
    </script>
    <style>
        body { font-family: 'Inter', sans-serif; }
        .game-canvas { image-rendering: pixelated; }
    </style>
</head>
<body class="bg-snake-bg text-gray-100 min-h-screen flex items-center justify-center p-4">
    <div class="w-full max-w-2xl">
        <!-- Header -->
        <div class="text-center mb-6">
            <h1 class="text-3xl md:text-4xl font-bold text-snake-green mb-2">Snake Game</h1>
            <p class="text-gray-400">Use Arrow Keys or WASD to move</p>
        </div>

        <!-- Score Display -->
        <div class="flex justify-between items-center mb-4 px-2">
            <div class="bg-snake-card rounded-xl px-6 py-3">
                <div class="text-gray-400 text-sm">Score</div>
                <div id="score" class="text-2xl font-bold text-white">0</div>
            </div>
            <div class="bg-snake-card rounded-xl px-6 py-3">
                <div class="text-gray-400 text-sm">High Score</div>
                <div id="highScore" class="text-2xl font-bold text-snake-green">0</div>
            </div>
        </div>

        <!-- Game Container -->
        <div class="relative bg-snake-card rounded-2xl p-4 shadow-2xl">
            <canvas id="gameCanvas" class="game-canvas w-full rounded-lg"></canvas>

            <!-- Main Menu Overlay -->
            <div id="mainMenu" class="absolute inset-0 bg-snake-bg/95 rounded-2xl flex flex-col items-center justify-center p-8">
                <div class="text-6xl mb-6">üêç</div>
                <h2 class="text-3xl font-bold text-white mb-8">Snake Game</h2>

                <div class="w-full max-w-xs space-y-4">
                    <button id="startBtn" class="w-full bg-snake-green hover:bg-snake-dark text-white font-bold py-4 px-8 rounded-xl transition-colors text-lg">
                        Start Game
                    </button>

                    <div class="bg-snake-card rounded-xl p-4">
                        <div class="text-gray-400 text-sm mb-3 text-center">Difficulty</div>
                        <div class="grid grid-cols-2 gap-2">
                            <button data-difficulty="easy" class="difficulty-btn bg-snake-bg hover:bg-snake-green/20 text-snake-green font-medium py-2 px-4 rounded-lg transition-colors border-2 border-snake-green">Easy</button>
                            <button data-difficulty="medium" class="difficulty-btn bg-snake-bg hover:bg-yellow-500/20 text-yellow-400 font-medium py-2 px-4 rounded-lg transition-colors border-2 border-transparent">Medium</button>
                            <button data-difficulty="hard" class="difficulty-btn bg-snake-bg hover:bg-orange-500/20 text-orange-400 font-medium py-2 px-4 rounded-lg transition-colors border-2 border-transparent">Hard</button>
                            <button data-difficulty="expert" class="difficulty-btn bg-snake-bg hover:bg-red-500/20 text-red-400 font-medium py-2 px-4 rounded-lg transition-colors border-2 border-transparent">Expert</button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Pause Overlay -->
            <div id="pauseMenu" class="hidden absolute inset-0 bg-snake-bg/95 rounded-2xl flex flex-col items-center justify-center p-8">
                <h2 class="text-3xl font-bold text-white mb-8">Paused</h2>
                <div class="space-y-4 w-full max-w-xs">
                    <button id="resumeBtn" class="w-full bg-snake-green hover:bg-snake-dark text-white font-bold py-4 px-8 rounded-xl transition-colors">
                        Resume
                    </button>
                    <button id="restartFromPauseBtn" class="w-full bg-snake-card hover:bg-gray-600 text-white font-bold py-4 px-8 rounded-xl transition-colors">
                        Restart
                    </button>
                    <button id="mainMenuFromPauseBtn" class="w-full bg-snake-card hover:bg-gray-600 text-white font-bold py-4 px-8 rounded-xl transition-colors">
                        Main Menu
                    </button>
                </div>
            </div>

            <!-- Game Over Overlay -->
            <div id="gameOverMenu" class="hidden absolute inset-0 bg-snake-bg/95 rounded-2xl flex flex-col items-center justify-center p-8">
                <h2 class="text-3xl font-bold text-red-500 mb-4">Game Over</h2>
                <div id="newHighScore" class="hidden text-snake-green font-bold text-xl mb-4 animate-pulse">New High Score!</div>
                <div class="text-gray-400 mb-2">Final Score</div>
                <div id="finalScore" class="text-5xl font-bold text-white mb-8">0</div>
                <div class="space-y-4 w-full max-w-xs">
                    <button id="playAgainBtn" class="w-full bg-snake-green hover:bg-snake-dark text-white font-bold py-4 px-8 rounded-xl transition-colors">
                        Play Again
                    </button>
                    <button id="mainMenuBtn" class="w-full bg-snake-card hover:bg-gray-600 text-white font-bold py-4 px-8 rounded-xl transition-colors">
                        Main Menu
                    </button>
                </div>
            </div>
        </div>

        <!-- Controls Info -->
        <div class="mt-6 flex flex-wrap justify-center gap-4 text-sm text-gray-400">
            <div><kbd class="bg-snake-card px-2 py-1 rounded">Space</kbd> / <kbd class="bg-snake-card px-2 py-1 rounded">P</kbd> Pause</div>
            <div><kbd class="bg-snake-card px-2 py-1 rounded">R</kbd> Restart</div>
            <div><kbd class="bg-snake-card px-2 py-1 rounded">Esc</kbd> Menu</div>
        </div>
    </div>

    <script>
        // Game Configuration
        const CONFIG = {
            gridSize: 20,
            cellSize: 20,
            initialSnakeLength: 4,
            pointsPerFood: 10,
            difficulties: {
                easy: { fps: 8, color: '#22c55e' },
                medium: { fps: 12, color: '#facc15' },
                hard: { fps: 18, color: '#f97316' },
                expert: { fps: 25, color: '#ef4444' }
            }
        };

        // Game State
        const game = {
            state: 'menu', // menu, playing, paused, gameover
            difficulty: 'easy',
            score: 0,
            highScore: parseInt(localStorage.getItem('snakeHighScore')) || 0,
            snake: [],
            direction: { x: 1, y: 0 },
            nextDirection: { x: 1, y: 0 },
            food: { x: 0, y: 0 },
            lastUpdate: 0,
            inputBuffer: null
        };

        // DOM Elements
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score');
        const highScoreEl = document.getElementById('highScore');
        const finalScoreEl = document.getElementById('finalScore');
        const mainMenu = document.getElementById('mainMenu');
        const pauseMenu = document.getElementById('pauseMenu');
        const gameOverMenu = document.getElementById('gameOverMenu');
        const newHighScoreEl = document.getElementById('newHighScore');

        // Initialize canvas size
        function initCanvas() {
            const containerWidth = canvas.parentElement.clientWidth - 32;
            const size = Math.min(containerWidth, CONFIG.gridSize * CONFIG.cellSize);
            const cellSize = Math.floor(size / CONFIG.gridSize);

            canvas.width = cellSize * CONFIG.gridSize;
            canvas.height = cellSize * CONFIG.gridSize;
            CONFIG.cellSize = cellSize;
        }

        // Initialize game
        function initGame() {
            const startX = Math.floor(CONFIG.gridSize / 4);
            const startY = Math.floor(CONFIG.gridSize / 2);

            game.snake = [];
            for (let i = 0; i < CONFIG.initialSnakeLength; i++) {
                game.snake.push({ x: startX - i, y: startY });
            }

            game.direction = { x: 1, y: 0 };
            game.nextDirection = { x: 1, y: 0 };
            game.score = 0;
            game.inputBuffer = null;
            scoreEl.textContent = '0';

            spawnFood();
        }

        // Spawn food at random position
        function spawnFood() {
            let validPosition = false;
            while (!validPosition) {
                game.food = {
                    x: Math.floor(Math.random() * CONFIG.gridSize),
                    y: Math.floor(Math.random() * CONFIG.gridSize)
                };

                validPosition = !game.snake.some(
                    segment => segment.x === game.food.x && segment.y === game.food.y
                );
            }
        }

        // Update game state
        function update() {
            // Apply buffered input
            if (game.inputBuffer) {
                game.direction = game.inputBuffer;
                game.inputBuffer = null;
            } else {
                game.direction = { ...game.nextDirection };
            }

            // Calculate new head position
            const head = { ...game.snake[0] };
            head.x += game.direction.x;
            head.y += game.direction.y;

            // Check wall collision
            if (head.x < 0 || head.x >= CONFIG.gridSize ||
                head.y < 0 || head.y >= CONFIG.gridSize) {
                gameOver();
                return;
            }

            // Check self collision
            if (game.snake.some(segment => segment.x === head.x && segment.y === head.y)) {
                gameOver();
                return;
            }

            // Add new head
            game.snake.unshift(head);

            // Check food collision
            if (head.x === game.food.x && head.y === game.food.y) {
                game.score += CONFIG.pointsPerFood;
                scoreEl.textContent = game.score;
                spawnFood();
            } else {
                // Remove tail if no food eaten
                game.snake.pop();
            }
        }

        // Render game
        function render() {
            const cellSize = CONFIG.cellSize;

            // Clear canvas
            ctx.fillStyle = '#1e293b';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw grid
            ctx.strokeStyle = '#334155';
            ctx.lineWidth = 0.5;
            for (let i = 0; i <= CONFIG.gridSize; i++) {
                ctx.beginPath();
                ctx.moveTo(i * cellSize, 0);
                ctx.lineTo(i * cellSize, canvas.height);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(0, i * cellSize);
                ctx.lineTo(canvas.width, i * cellSize);
                ctx.stroke();
            }

            // Draw food
            const foodPadding = cellSize * 0.15;
            ctx.fillStyle = '#ef4444';
            ctx.beginPath();
            ctx.arc(
                game.food.x * cellSize + cellSize / 2,
                game.food.y * cellSize + cellSize / 2,
                cellSize / 2 - foodPadding,
                0,
                Math.PI * 2
            );
            ctx.fill();

            // Food shine effect
            ctx.fillStyle = '#fca5a5';
            ctx.beginPath();
            ctx.arc(
                game.food.x * cellSize + cellSize / 2 - cellSize * 0.15,
                game.food.y * cellSize + cellSize / 2 - cellSize * 0.15,
                cellSize * 0.12,
                0,
                Math.PI * 2
            );
            ctx.fill();

            // Draw snake
            const difficultyColor = CONFIG.difficulties[game.difficulty].color;
            game.snake.forEach((segment, index) => {
                const padding = cellSize * 0.08;
                const x = segment.x * cellSize + padding;
                const y = segment.y * cellSize + padding;
                const size = cellSize - padding * 2;
                const radius = cellSize * 0.2;

                // Gradient from head to tail
                const alpha = 1 - (index / game.snake.length) * 0.4;

                if (index === 0) {
                    // Head - brighter
                    ctx.fillStyle = difficultyColor;
                } else {
                    ctx.fillStyle = difficultyColor + Math.floor(alpha * 255).toString(16).padStart(2, '0');
                }

                // Rounded rectangle
                ctx.beginPath();
                ctx.roundRect(x, y, size, size, radius);
                ctx.fill();

                // Draw eyes on head
                if (index === 0) {
                    ctx.fillStyle = '#0f172a';
                    const eyeSize = cellSize * 0.12;
                    const eyeOffset = cellSize * 0.18;

                    let eye1X, eye1Y, eye2X, eye2Y;

                    if (game.direction.x === 1) { // Right
                        eye1X = segment.x * cellSize + cellSize * 0.7;
                        eye1Y = segment.y * cellSize + cellSize * 0.3;
                        eye2X = segment.x * cellSize + cellSize * 0.7;
                        eye2Y = segment.y * cellSize + cellSize * 0.7;
                    } else if (game.direction.x === -1) { // Left
                        eye1X = segment.x * cellSize + cellSize * 0.3;
                        eye1Y = segment.y * cellSize + cellSize * 0.3;
                        eye2X = segment.x * cellSize + cellSize * 0.3;
                        eye2Y = segment.y * cellSize + cellSize * 0.7;
                    } else if (game.direction.y === -1) { // Up
                        eye1X = segment.x * cellSize + cellSize * 0.3;
                        eye1Y = segment.y * cellSize + cellSize * 0.3;
                        eye2X = segment.x * cellSize + cellSize * 0.7;
                        eye2Y = segment.y * cellSize + cellSize * 0.3;
                    } else { // Down
                        eye1X = segment.x * cellSize + cellSize * 0.3;
                        eye1Y = segment.y * cellSize + cellSize * 0.7;
                        eye2X = segment.x * cellSize + cellSize * 0.7;
                        eye2Y = segment.y * cellSize + cellSize * 0.7;
                    }

                    ctx.beginPath();
                    ctx.arc(eye1X, eye1Y, eyeSize, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(eye2X, eye2Y, eyeSize, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
        }

        // Game over
        function gameOver() {
            game.state = 'gameover';

            // Check for new high score
            const isNewHighScore = game.score > game.highScore;
            if (isNewHighScore) {
                game.highScore = game.score;
                localStorage.setItem('snakeHighScore', game.highScore);
                highScoreEl.textContent = game.highScore;
            }

            finalScoreEl.textContent = game.score;
            newHighScoreEl.classList.toggle('hidden', !isNewHighScore);
            gameOverMenu.classList.remove('hidden');
        }

        // Game loop
        function gameLoop(timestamp) {
            if (game.state === 'playing') {
                const fps = CONFIG.difficulties[game.difficulty].fps;
                const frameTime = 1000 / fps;

                if (timestamp - game.lastUpdate >= frameTime) {
                    update();
                    game.lastUpdate = timestamp;
                }

                render();
            }

            requestAnimationFrame(gameLoop);
        }

        // Input handling
        function handleKeyDown(e) {
            const key = e.key.toLowerCase();

            // Prevent scrolling with arrow keys
            if (['arrowup', 'arrowdown', 'arrowleft', 'arrowright', ' '].includes(e.key.toLowerCase()) ||
                ['arrowup', 'arrowdown', 'arrowleft', 'arrowright', ' '].includes(e.key)) {
                e.preventDefault();
            }

            if (game.state === 'playing') {
                let newDirection = null;

                // Direction changes
                if ((key === 'arrowup' || key === 'w') && game.direction.y !== 1) {
                    newDirection = { x: 0, y: -1 };
                } else if ((key === 'arrowdown' || key === 's') && game.direction.y !== -1) {
                    newDirection = { x: 0, y: 1 };
                } else if ((key === 'arrowleft' || key === 'a') && game.direction.x !== 1) {
                    newDirection = { x: -1, y: 0 };
                } else if ((key === 'arrowright' || key === 'd') && game.direction.x !== -1) {
                    newDirection = { x: 1, y: 0 };
                }

                if (newDirection) {
                    // Buffer input for smooth direction changes
                    if (game.inputBuffer === null) {
                        game.nextDirection = newDirection;
                    } else {
                        game.inputBuffer = newDirection;
                    }
                }

                // Pause
                if (key === ' ' || key === 'p') {
                    game.state = 'paused';
                    pauseMenu.classList.remove('hidden');
                }

                // Quick restart
                if (key === 'r') {
                    initGame();
                }
            } else if (game.state === 'paused') {
                if (key === ' ' || key === 'p' || key === 'escape') {
                    resumeGame();
                }
            } else if (game.state === 'gameover') {
                if (key === 'enter' || key === 'r') {
                    startGame();
                }
            } else if (game.state === 'menu') {
                if (key === 'enter') {
                    startGame();
                }
            }

            // Return to main menu
            if (key === 'escape' && game.state !== 'menu') {
                showMainMenu();
            }
        }

        // UI Functions
        function startGame() {
            initGame();
            game.state = 'playing';
            game.lastUpdate = performance.now();
            mainMenu.classList.add('hidden');
            pauseMenu.classList.add('hidden');
            gameOverMenu.classList.add('hidden');
            render();
        }

        function resumeGame() {
            game.state = 'playing';
            game.lastUpdate = performance.now();
            pauseMenu.classList.add('hidden');
        }

        function showMainMenu() {
            game.state = 'menu';
            mainMenu.classList.remove('hidden');
            pauseMenu.classList.add('hidden');
            gameOverMenu.classList.add('hidden');
        }

        function setDifficulty(difficulty) {
            game.difficulty = difficulty;
            document.querySelectorAll('.difficulty-btn').forEach(btn => {
                const btnDiff = btn.dataset.difficulty;
                const isSelected = btnDiff === difficulty;
                btn.classList.toggle('border-transparent', !isSelected);

                if (isSelected) {
                    if (btnDiff === 'easy') btn.classList.add('border-snake-green');
                    else if (btnDiff === 'medium') btn.classList.add('border-yellow-400');
                    else if (btnDiff === 'hard') btn.classList.add('border-orange-400');
                    else if (btnDiff === 'expert') btn.classList.add('border-red-400');
                } else {
                    btn.classList.remove('border-snake-green', 'border-yellow-400', 'border-orange-400', 'border-red-400');
                }
            });
        }

        // Event Listeners
        document.addEventListener('keydown', handleKeyDown);
        document.getElementById('startBtn').addEventListener('click', startGame);
        document.getElementById('resumeBtn').addEventListener('click', resumeGame);
        document.getElementById('restartFromPauseBtn').addEventListener('click', startGame);
        document.getElementById('mainMenuFromPauseBtn').addEventListener('click', showMainMenu);
        document.getElementById('playAgainBtn').addEventListener('click', startGame);
        document.getElementById('mainMenuBtn').addEventListener('click', showMainMenu);

        document.querySelectorAll('.difficulty-btn').forEach(btn => {
            btn.addEventListener('click', () => setDifficulty(btn.dataset.difficulty));
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            initCanvas();
            if (game.state !== 'menu') {
                render();
            }
        });

        // Initialize
        initCanvas();
        highScoreEl.textContent = game.highScore;
        initGame();
        render();
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
